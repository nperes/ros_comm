/*
 * security_module.h
 *
 *      Author: nmf
 */

#ifndef ROSCPP_SECURITY_MODULE_H_
#define ROSCPP_SECURITY_MODULE_H_

#include <boost/enable_shared_from_this.hpp>
#include <boost/shared_ptr.hpp>
#include <boost/shared_array.hpp>
#include <boost/function.hpp>

#include <openssl/evp.h>

namespace ros {

class SecurityModule;

typedef boost::shared_ptr<SecurityModule> SecurityModulePtr;
typedef boost::function<bool(boost::shared_array<uint8_t>, size_t)> PeerKeyRetrievedFunc;

/**
 * \brief Support for cryptographic operations, including Diffie-Hellman (DH)
 * exchange, HMAC generation and encryption.
 */
class SecurityModule: public boost::enable_shared_from_this<SecurityModule> {

public:

	enum Flags {
		HMACS = 1 << 0,
		ENCRYPTION = 1 << 1
	};

	SecurityModule(int flags = 0);
	virtual ~SecurityModule();

	/**
	 * \brief Generates a Diffie-Hellman (DH) key-pair and puts the public key
	 * and DH parameters into dh_public_key.
	 * Initialization is incomplete until the DH peer-key is provided through
	 * callback to peerKeyRetrievedFunction
	 *
	 * This method generates the DH key-pair from a predefined/agreed set of
	 * parameters and expects the DH peer key to have been generated using
	 * the same set of parameters.
	 *
	 * \params dh_public_key The public key as well as the parameters
	 * 		used to generate it, in .der encoding.
	 * \params dh_public_key_len Number of bytes in dh_public_key
	 * \params peerKeyRetrievedCallback Function to call when the DH peer key for
	 * 		becomes obtained.
	 */
	bool initialize(boost::shared_array<uint8_t> &dh_public_key,
	  size_t &dh_public_key_len,
	  PeerKeyRetrievedFunc &peerKeyRetrievedCallback);

	/**
	 * \brief Generates a Diffie-Hellman (DH) key-pair using the DH peer-key
	 * 	information provided by dh_peer_key, and puts the generated DH public key
	 * 	and associated DH parameters into dh_public_key. Initialization is
	 * 	complete.
	 *
	 * The DH shared secret is generated at this point, along with the keys used
	 * for encryption and HMAC generation.
	 *
	 * \params dh_public_key The public key as well as the parameters
	 * 		used to generate it, in .der format.
	 * \params dh_public_key_len Number of bytes in dh_public_key
	 * \params dh_peer_key The peer-key for this DH exchange, along with the
	 * 		DH parameters used to generate it, in DER format.
	 * \params dh_peer_key_len Number of bytes in dh_peer_key
	 */
	bool initialize(boost::shared_array<uint8_t> &dh_public_key,
	    size_t &dh_public_len, const boost::shared_array<uint8_t>& dh_peer_key,
	    size_t dh_peer_key_len);

	/**
	 *  \brief Creates a secure data block containing the given plain data.
	 *
	 *  This method takes plain_data_size bytes starting at
	 *  plain_data_offset of plain_data and returns secure_data_size bytes
	 *  starting at secure_data_offset of secure_data. secure_data is organized
	 *  as follows: [ <secure_data_offset bytes> || HMAC || IV || ciphertext ].
	 */
	bool secure(const uint8_t *plain_data, uint32_t plain_data_size,
	    boost::shared_array<uint8_t> &secure_data, uint32_t &secure_data_size,
	    uint32_t secure_data_offset);

	/**
	 * \brief Retrieves the plain data contained in a secure data block and
	 * asserts its integrity.
	 *
	 *  This method takes secure_data_size bytes starting at
	 *  secure_data_offset of secure_data and returns plain_data_size bytes
	 *  starting at plain_data_offset of plain_data. secure_data is
	 *  expected to be organized as follows:
	 *  [ <secure_data_offset bytes> || HMAC || IV || ciphertext ].
	 */
	bool retrieve(const uint8_t *secure_data, uint32_t secure_data_size,
	    boost::shared_array<uint8_t> &plain_data, uint32_t &plain_data_size,
	    uint32_t plain_data_offset);

	SecurityModule& setHmacs(bool enable = true);
	SecurityModule& setEncryption(bool enable = true);

	bool dhParseKey(const uint8_t *dh_peer_key, size_t dh_peer_key_size);

private:

	bool setCryptoOps();

	/**
	 * \brief Sets internal state, generating a Diffie-Hellman (DH)
	 * public/private key-pair.
	 *
	 * The DH key-pair generated by this method uses a set of openssl built-in
	 * parameters (in particular the ones provided by DH_get_2048_256()).
	 */
	bool dhInitialize();

	/**
	 * \brief Sets internal state by generating a Diffie-Hellman (DH)
	 * public/private key-pair.
	 *
	 * The DH key-pair generated by this method uses the information provided
	 * by dh_peer_key, which is expected to contain a DH peer key in .der
	 * format. Both the DH public peer-key and DH parameters used to generate
	 * it must be encoded into dh_peer_keym so that this DH key-pair can be
	 * generated from the same parameters.
	 */
	bool dhInitialize(const uint8_t *dh_peer_key, uint32_t dh_peer_key_len);

	/**
	 * \brief Generates a Diffie-Hellman (DH) key-pair using the DH parameters
	 * in dh_params, placing the result into dh_keys.
	 *
	 */
	bool dhGenerateFromParams(EVP_PKEY *dh_params, EVP_PKEY* &dh_keys);

	/**
	 * \brief Callback to complete the Diffie-Hellman (DH) exchange initialized
	 * by this SecurityModule. The peer_key is expected to have been generated
	 * from the same set of DH parameters.
	 */
	bool onDhPeerKeyAvailable(boost::shared_array<uint8_t> peer_key,
	    size_t peer_key_len);

	/**
	 * \brief Places the dh_key_size bytes corresponding to the serialization
	 * of the Diffie-Hellman (DH) key dh_pkey into dh_key.
	 *
	 * \note dh_key is serialized following the .der format.
	 */
	bool dhSerialize(EVP_PKEY *dh_pkey,
	    boost::shared_array<uint8_t> &dh_key, size_t &dh_key_size);

	/**
	 * \brief Generates a shared secret (symmetric key) and other cryptographic
	 * material based on the Diffie-Hellman (DH) exchange.
	 *
	 * Private keys for encryption and HMAC generation are created here.
	 */
	bool onDhPeerKey();

	/**
	 * \brief Applies a hashed-based key derivation function based on salt,
	 * info and the member variable dh_secret_ to derive a cryptographic key of
	 * key_size bytes, placing the result in key.
	 */
	bool hkdfDeriveKey(const uint8_t *salt, size_t salt_size, const uint8_t *info,
	    size_t info_size, uint8_t *key, size_t key_size);


	/**
	 * \brief Derive the cryptographic key to be used for (SHA256-based) HMAC
	 * generation.
	 */
	bool deriveSha256HmacKey();

	/**
	 * \brief Derive the cryptographic key to be used for (AES256-based)
	 * encryption/decryption.
	 */
	bool deriveAes256EncryptionKey();


	bool aes256Encrypt(const uint8_t *plaintext, uint32_t plaintext_size,
	    boost::shared_array<uint8_t> &buffer, uint32_t &size, uint32_t offset);
	bool aes256Decrypt(const uint8_t *ciphered_data, uint32_t ciphered_data_len,
	    boost::shared_array<uint8_t> &plaintext, uint32_t &plaintext_size,
	    uint32_t offset);

	bool mdGenerate(const uint8_t *msg, uint32_t msg_len,
	    boost::shared_array<uint8_t>& md, uint32_t md_offset = 0);

	bool mdValidate(const uint8_t *msg, uint32_t msg_len, const uint8_t* md);

	bool evp_cipher(const uint8_t *input, int input_len, uint8_t *output,
	    uint32_t &output_len, const uint8_t *iv, bool encrypt);

	/// Diffie-Hellman keys
	EVP_PKEY *dh_keys_;
	/// shared cryptographic key - derived from Diffie-Hellman exchange
	uint8_t *dh_secret_;
	/// length of dh_secret_
	uint32_t dh_secret_len_;
	/// key for message digest algorithm - derived from dh_secret_
	uint8_t *md_key_;
	/// evp_key for message digest algorithm - created from md_key_
	EVP_PKEY *md_pkey_;
	/// size of md_key_
	size_t md_key_size_;
	/// cryptographic key for encryption - derived from dh_secret
	uint8_t *cipher_key_;
	/// size of cryptographic key for encryption
	EVP_PKEY *dh_public_peer_key_;
	const EVP_CIPHER *evp_cipher_;
	EVP_CIPHER_CTX *cipher_ctx_;
	const EVP_MD *md_algorithm_;
	EVP_MD_CTX *md_ctx_;
	uint32_t md_len_;
	int flags_;
};

} //namespace ros

#endif /* ROSCPP_SECURITY_MODULE_H_ */
